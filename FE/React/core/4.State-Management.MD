# ğŸŒ 1. Context API vs Redux vs Recoil/Zustand

| Tool             | Best For | Trade-offs |
|------------------|----------|------------|
| Context API      | Light global state: theme, user auth, locale | âœ… Built-in <br /> âŒ Re-renders all consumers unless optimized|
| Redux            | Complex, predictable state across large apps (e.g. enterprise) | âœ… Devtools, middleware, ecosystem <br /> âŒ Verbose, boilerplate|
| Recoil / Zustand | Simpler alternatives for scalable shared state | âœ… Less boilerplate, minimal <br /> âŒ Smaller ecosystem, different paradigms |

## ğŸ’¬ Interview Question:

"Why might you choose React Context over Redux in a new project? What trade-offs are you making?"

## âœ… Strong Answer:

* Iâ€™d choose Context over Redux if:
  * The state is simple (like a theme, language (locale), or authenticated user)
  * I want to avoid Reduxâ€™s boilerplate and setup
* Trade-offs include:
  * Context re-renders all consumers by default, which may hurt performance
  * No built-in debugging/devtools like Redux
* If performance becomes a concern, Iâ€™d combine Context with useMemo and component splitting to mitigate re-renders.

# ğŸ” 2. Prop Drilling and How to Avoid It

**Problem:** Passing props deeply through multiple layers that donâ€™t use them

### ğŸ§  Solutions:
* Use **Context** when many children need the same value (e.g., dark mode toggle)
* Use a **global store** (e.g., Zustand) for app-wide state
* Reorganize component structure to lift state closer to where itâ€™s needed

### Example:

```tsx
// Instead of drilling theme through 5 levels...
<Grandparent>
  <Parent>
    <Child theme={theme} />
  </Parent>
</Grandparent>

// Use Context
const ThemeContext = createContext();
<ThemeContext.Provider value={theme}>
  <Grandparent />
</ThemeContext.Provider>

```

# ğŸ”„ 3. Async State Handling

| Tool             | What It Does | When to Use |
|------------------|--------------|-------------|
| `useEffect`      | Manual async data handling | Simple fetch, on-mount logic |
| React Query      | Manages caching, retries, loading, errors for API calls | Ideal for REST APIs |
| SWR | Lightweight data fetching with cache and stale-while-revalidate | Good for read-heavy UIs |

### ğŸ’¬ Interview Question:

"How would you handle loading async user profile data?"

### âœ… Strong Answer:

If it's a simple one-off fetch, I might use useEffect. But for a real-world app with caching, loading states, and error boundaries, Iâ€™d use React Query or SWR.

### Example with `useQuery` from React Query:

```tsx
const { data, isLoading, error } = useQuery(['user', userId], () =>
  fetch(`/api/user/${userId}`).then(res => res.json())
);

```

* This gives me retries, stale cache, refetch on window focus â€” all out of the box.

# ğŸ§  State Management Summary


| Topic | Key Takeaway |
|-------|--------------|
| Context vs Redux | Use Context for light state, Redux for large/global/complex workflows |
| Recoil/Zustand | Use for simpler syntax, less boilerplate, and scoped state |
| Prop Drilling | Avoid by using Context or a global store |
| Async State Handling | Use `useEffect` for basic, `useSWR` or `React Query` for production APIs |
