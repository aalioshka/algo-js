# 🌐 1. Context API vs Redux vs Recoil/Zustand

| Tool             | Best For | Trade-offs |
|------------------|----------|------------|
| Context API      | Light global state: theme, user auth, locale | ✅ Built-in <br /> ❌ Re-renders all consumers unless optimized|
| Redux            | Complex, predictable state across large apps (e.g. enterprise) | ✅ Devtools, middleware, ecosystem <br /> ❌ Verbose, boilerplate|
| Recoil / Zustand | Simpler alternatives for scalable shared state | ✅ Less boilerplate, minimal <br /> ❌ Smaller ecosystem, different paradigms |

## 💬 Interview Question:

"Why might you choose React Context over Redux in a new project? What trade-offs are you making?"

## ✅ Strong Answer:

* I’d choose Context over Redux if:
  * The state is simple (like a theme, language (locale), or authenticated user)
  * I want to avoid Redux’s boilerplate and setup
* Trade-offs include:
  * Context re-renders all consumers by default, which may hurt performance
  * No built-in debugging/devtools like Redux
* If performance becomes a concern, I’d combine Context with useMemo and component splitting to mitigate re-renders.

# 🔁 2. Prop Drilling and How to Avoid It

**Problem:** Passing props deeply through multiple layers that don’t use them

### 🧠 Solutions:
* Use **Context** when many children need the same value (e.g., dark mode toggle)
* Use a **global store** (e.g., Zustand) for app-wide state
* Reorganize component structure to lift state closer to where it’s needed

### Example:

```tsx
// Instead of drilling theme through 5 levels...
<Grandparent>
  <Parent>
    <Child theme={theme} />
  </Parent>
</Grandparent>

// Use Context
const ThemeContext = createContext();
<ThemeContext.Provider value={theme}>
  <Grandparent />
</ThemeContext.Provider>

```

# 🔄 3. Async State Handling

| Tool             | What It Does | When to Use |
|------------------|--------------|-------------|
| `useEffect`      | Manual async data handling | Simple fetch, on-mount logic |
| React Query      | Manages caching, retries, loading, errors for API calls | Ideal for REST APIs |
| SWR | Lightweight data fetching with cache and stale-while-revalidate | Good for read-heavy UIs |

### 💬 Interview Question:

"How would you handle loading async user profile data?"

### ✅ Strong Answer:

If it's a simple one-off fetch, I might use useEffect. But for a real-world app with caching, loading states, and error boundaries, I’d use React Query or SWR.

### Example with `useQuery` from React Query:

```tsx
const { data, isLoading, error } = useQuery(['user', userId], () =>
  fetch(`/api/user/${userId}`).then(res => res.json())
);

```

* This gives me retries, stale cache, refetch on window focus — all out of the box.

# 🧠 State Management Summary


| Topic | Key Takeaway |
|-------|--------------|
| Context vs Redux | Use Context for light state, Redux for large/global/complex workflows |
| Recoil/Zustand | Use for simpler syntax, less boilerplate, and scoped state |
| Prop Drilling | Avoid by using Context or a global store |
| Async State Handling | Use `useEffect` for basic, `useSWR` or `React Query` for production APIs |
